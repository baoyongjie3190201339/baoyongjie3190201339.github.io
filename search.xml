<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【学习日记】移植LVGL(基于STM32F103ZET6)</title>
      <link href="/2024/01/28/FreeRTOS/lvgl_yizhi/"/>
      <url>/2024/01/28/FreeRTOS/lvgl_yizhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录在FreeRTOS系统上移植LVGL。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>1.硬件</strong><br>最好使用一块带触摸屏的开发板，这里使用的是STM32F103ZET6<br><strong>2.软件</strong></p><ul><li><a href="https://github.com/lvgl/lvgl">LVGL源码下载地址</a></li><li><a href="http://www.openedv.com/docs/book-videos/zdyzshipin/4free/newlvgl.html">正点原子资料下载地址</a></li></ul><h3 id="裸机移植"><a href="#裸机移植" class="headerlink" title="裸机移植"></a>裸机移植</h3><p>下载完LVGL源码后我们需要保留以下文件   </p><p><img src="/img/freertos/lvgl_yizhi/1.png" alt="1">   </p><p>由于LVGL的移植较为繁琐，这里我们先进行裸机的移植，完成后再进行FreeRTOS的移植。</p><h4 id="1-工程文件配置"><a href="#1-工程文件配置" class="headerlink" title="1.工程文件配置"></a>1.工程文件配置</h4><p>对于裸机的移植，我们需要准备以下工程   </p><p><img src="/img/freertos/lvgl_yizhi/2.png" alt="1"><br>我们以触摸屏实验作为移植后的工程文件，将其改名为LVGL移植1   </p><p><img src="/img/freertos/lvgl_yizhi/4.png" alt="1"><br>接下来我们需要做以下几步   </p><p><img src="/img/freertos/lvgl_yizhi/5.png" alt="1"></p><p>完成后在keil内新建分组以及相关.c文件   </p><p><img src="/img/freertos/lvgl_yizhi/6.png" alt="1">   </p><p><img src="/img/freertos/lvgl_yizhi/7.png" alt="1"></p><p>添加头文件路径   </p><p><img src="/img/freertos/lvgl_yizhi/8.png" alt="1"></p><p>开启keil的C99模式，编译后剩下的警告不用管   </p><p><img src="/img/freertos/lvgl_yizhi/9.png" alt="1"></p><h4 id="2-触摸屏配置输出"><a href="#2-触摸屏配置输出" class="headerlink" title="2.触摸屏配置输出"></a>2.触摸屏配置输出</h4><p>1.将 <code>lv_port_disp_template.c/h</code> 的条件编译指令 #if 0 修改成 #if 1   </p><p>2.在<code>lv_port_disp_template.c</code>中包含LCD的头文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/LCD/lcd.h&quot;</span></span></span><br></pre></td></tr></table></figure></p><p>在 disp_init 函数中初始化屏幕设备，设置横屏<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*You code here*/</span></span><br><span class="line">  lcd_init();</span><br><span class="line">  lcd_display_dir(<span class="number">1</span>); <span class="comment">/*1为横屏，0为竖屏*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.配置图形数据缓冲模式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Example for 1) */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span> draw_buf_dsc_1;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_color_t</span> buf_1[MY_DISP_HOR_RES * <span class="number">10</span>];                          <span class="comment">/*A buffer for 10 rows*/</span></span><br><span class="line">    lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, <span class="literal">NULL</span>, MY_DISP_HOR_RES * <span class="number">10</span>);   <span class="comment">/*Initialize the display buffer*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    /* Example for 2) */</span></span><br><span class="line"><span class="comment">//    static lv_disp_draw_buf_t draw_buf_dsc_2;</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_2_1[MY_DISP_HOR_RES * 10];                        /*A buffer for 10 rows*/</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_2_2[MY_DISP_HOR_RES * 10];                        /*An other buffer for 10 rows*/</span></span><br><span class="line"><span class="comment">//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_2, buf_2_1, buf_2_2, MY_DISP_HOR_RES * 10);   /*Initialize the display buffer*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    /* Example for 3) also set disp_drv.full_refresh = 1 below*/</span></span><br><span class="line"><span class="comment">//    static lv_disp_draw_buf_t draw_buf_dsc_3;</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*A screen sized buffer*/</span></span><br><span class="line"><span class="comment">//    static lv_color_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*Another screen sized buffer*/</span></span><br><span class="line"><span class="comment">//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_3, buf_3_1, buf_3_2, MY_DISP_VER_RES * LV_VER_RES_MAX);   /*Initialize the display buffer*/</span></span><br></pre></td></tr></table></figure><br>这是LVGL提供的三种图形缓冲模式    </p><p><code>单缓冲区:</code><br>LVGL 会将显示设备的内容绘制到这里，并将他写入显示设备。     </p><p><code>双缓冲区:</code><br>LVGL 会将显示设备的内容绘制到其中一个缓冲区，并将他写入显示设备。需要使用 DMA 将要显示在显示设备的内容写入缓冲区。当数据从第一个缓冲区发送时，它将使 LVGL 能够将屏幕的下一部分绘制到另一个缓冲区。这样使得渲染和刷新可以并行执行。</p><p><code>全尺寸双缓冲区:</code><br>设置两个屏幕大小的全尺寸缓冲区，并且设置 disp_drv.full_refresh = 1。<br>LVGL 将始终以 ‘flush_cb’ 的形式提供整个渲染屏幕，只需更改帧缓冲区的地址。</p><p>这里我们选择第一种，将下面两种注释或者删除。</p><p>4.配置屏幕尺寸<br>这里我们使用了正点原子动态获取屏幕尺寸的方式，当屏幕改变时不需要手动修改屏幕尺寸。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Set the resolution of the display*/</span></span><br><span class="line">disp_drv.hor_res = lcddev.width;</span><br><span class="line">disp_drv.ver_res = lcddev.height;</span><br></pre></td></tr></table></figure></p><p>5.在 disp_flush 函数中配置打点输出   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="type">lv_disp_drv_t</span> * disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> * area, <span class="type">lv_color_t</span> * color_p)</span></span><br><span class="line">&#123;</span><br><span class="line">lcd_color_fill(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2, (<span class="type">uint16_t</span>*)color_p);</span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-触摸屏配置输入"><a href="#3-触摸屏配置输入" class="headerlink" title="3.触摸屏配置输入"></a>3.触摸屏配置输入</h4><p>1.将 <code>lv_port_indev_template.c/h</code> 的条件编译指令 #if 0 修改成 #if 1 </p><p>2.按需要裁剪输入设备<br>由于我们的设备输入只有触摸，所以只保留触摸相关   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_read</span><span class="params">(<span class="type">lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">touchpad_is_pressed</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_get_xy</span><span class="params">(<span class="type">lv_coord_t</span> * x, <span class="type">lv_coord_t</span> * y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void mouse_init(void);</span></span><br><span class="line"><span class="comment">//static void mouse_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">//static bool mouse_is_pressed(void);</span></span><br><span class="line"><span class="comment">//static void mouse_get_xy(lv_coord_t * x, lv_coord_t * y);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void keypad_init(void);</span></span><br><span class="line"><span class="comment">//static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">//static uint32_t keypad_get_key(void);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void encoder_init(void);</span></span><br><span class="line"><span class="comment">//static void encoder_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">//static void encoder_handler(void);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void button_init(void);</span></span><br><span class="line"><span class="comment">//static void button_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);</span></span><br><span class="line"><span class="comment">//static int8_t button_get_pressed_id(void);</span></span><br><span class="line"><span class="comment">//static bool button_is_pressed(uint8_t id);</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment"> *  STATIC VARIABLES</span></span><br><span class="line"><span class="comment"> **********************/</span></span><br><span class="line"><span class="type">lv_indev_t</span> * indev_touchpad;</span><br><span class="line"><span class="comment">//lv_indev_t * indev_mouse;</span></span><br><span class="line"><span class="comment">//lv_indev_t * indev_keypad;</span></span><br><span class="line"><span class="comment">//lv_indev_t * indev_encoder;</span></span><br><span class="line"><span class="comment">//lv_indev_t * indev_button;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int32_t encoder_diff;</span></span><br><span class="line"><span class="comment">//static lv_indev_state_t encoder_state;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lv_port_indev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">    <span class="comment">/*------------------</span></span><br><span class="line"><span class="comment">     * Touchpad</span></span><br><span class="line"><span class="comment">     * -----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize your touchpad if you have*/</span></span><br><span class="line">    touchpad_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Register a touchpad input device*/</span></span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);</span><br><span class="line">    indev_drv.type = LV_INDEV_TYPE_POINTER;</span><br><span class="line">    indev_drv.read_cb = touchpad_read;</span><br><span class="line">    indev_touchpad = lv_indev_drv_register(&amp;indev_drv);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------</span></span><br><span class="line"><span class="comment"> * Touchpad</span></span><br><span class="line"><span class="comment"> * -----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Will be called by the library to read the touchpad*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_read</span><span class="params">(<span class="type">lv_indev_drv_t</span> * indev_drv, <span class="type">lv_indev_data_t</span> * data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_coord_t</span> last_x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">lv_coord_t</span> last_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Save the pressed coordinates and the state*/</span></span><br><span class="line">    <span class="keyword">if</span>(touchpad_is_pressed()) &#123;</span><br><span class="line">        touchpad_get_xy(&amp;last_x, &amp;last_y);</span><br><span class="line">        data-&gt;state = LV_INDEV_STATE_PR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data-&gt;state = LV_INDEV_STATE_REL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Set the last pressed coordinates*/</span></span><br><span class="line">    data-&gt;point.x = last_x;</span><br><span class="line">    data-&gt;point.y = last_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.包含输入设备驱动头文件   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/TOUCH/touch.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>4.在 touchpad_init 函数中初始化触摸屏   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">tp_dev.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.配置触摸检测函数   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">touchpad_is_pressed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">tp_dev.scan(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(tp_dev.sta &amp;TP_PRES_DOWN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.配置坐标获取函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Get the x and y coordinates if the touchpad is pressed*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_get_xy</span><span class="params">(<span class="type">lv_coord_t</span> * x, <span class="type">lv_coord_t</span> * y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line"></span><br><span class="line">    (*x) = tp_dev.x[<span class="number">0</span>];</span><br><span class="line">    (*y) = tp_dev.y[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-提供时基"><a href="#4-提供时基" class="headerlink" title="4.提供时基"></a>4.提供时基</h4><p>1.添加定时器驱动   </p><p><img src="/img/freertos/lvgl_yizhi/10.png" alt="1">   </p><p>添加.c文件和.h文件   </p><p>2.在定时器驱动.c文件中包含：#include “lvgl.h”   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.在定时器中断函数（回调）中调用：lv_tick_inc(x);<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Instance == BTIM_TIMX_INT)</span><br><span class="line">    &#123;</span><br><span class="line">       lv_tick_inc(<span class="number">1</span>);<span class="comment">/* LED1反转 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-配置main函数"><a href="#5-配置main函数" class="headerlink" title="5.配置main函数"></a>5.配置main函数</h4><p>1.添加头文件    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/TIMER/btim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>初始化定时器、LVGL库、输入输出设备    </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="title function_">btim_timx_int_init</span><span class="params">(<span class="number">10</span><span class="number">-1</span>, <span class="number">7200</span><span class="number">-1</span>)</span>;<span class="comment">/*主频72Mhz*/</span></span><br><span class="line">lv_init(); </span><br><span class="line">lv_port_disp_init(); </span><br><span class="line">lv_port_indev_init();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.在while中每隔5ms调用一次lv_timer_handler();   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">lv_timer_handler(); <span class="comment">/* LVGL 管理函数相当于 RTOS 触发任务调度函数 */</span></span><br><span class="line">delay_ms(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.进行测试<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>* switch_obj = lv_switch_create(lv_scr_act());</span><br><span class="line">lv_obj_set_size(switch_obj, <span class="number">120</span>, <span class="number">60</span>);</span><br><span class="line">lv_obj_align(switch_obj, LV_ALIGN_CENTER, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h3 id="在FreeRTOS上移植LVGL"><a href="#在FreeRTOS上移植LVGL" class="headerlink" title="在FreeRTOS上移植LVGL"></a>在FreeRTOS上移植LVGL</h3><h4 id="1-移植准备"><a href="#1-移植准备" class="headerlink" title="1.移植准备"></a>1.移植准备</h4><p>这里我们需要准备两个工程，一个为之前裸机移植的工程，将其改名为LVGL移植2，另一个工程为FreeRTOS工程，关于如何移植FreeRTOS，可以查看往期教程</p><ul><li><a href="https://baoyongjie3190201339.github.io/2023/12/28/FreeRTOS/yizhi/">FreeRTOS移植</a>   </li></ul><p><img src="/img/freertos/lvgl_yizhi/11.png" alt="1"></p><h4 id="2-移植FreeRTOS相关文件"><a href="#2-移植FreeRTOS相关文件" class="headerlink" title="2.移植FreeRTOS相关文件"></a>2.移植FreeRTOS相关文件</h4><p>1.添加文件   </p><p><img src="/img/freertos/lvgl_yizhi/3.png" alt="1">   </p><p>2.在keil内添加分组<br><img src="/img/freertos/lvgl_yizhi/12.png" alt="1"></p><p>3.添加对应的.c文件<br><img src="/img/freertos/lvgl_yizhi/13.png" alt="1"></p><p>4.添加头文件路径<br><img src="/img/freertos/lvgl_yizhi/14.png" alt="1">     </p><p>5.打开HAL库中断相关的.c文件，屏蔽SysTick 中断、SVC 中断、PendSV 中断<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SVCall exception.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//void SVC_Handler(void)   屏蔽SVC中断</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles PendSVC exception.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//void PendSV_Handler(void)  屏蔽PendSV中断</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function handles SysTick Handler .</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//void SysTick_Handler(void)  屏蔽SysTick中断</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  HAL_IncTick();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p><p>6.修改宏定义__NVIC_PRIO_BITS   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NVIC_PRIO_BITS           4       <span class="comment">/*在stm32f103xe.h中，4U改为4*/</span></span></span><br></pre></td></tr></table></figure><p>7.在lv_conf.h文件中配置自定义时钟源，删除定时器提供时基的部分代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Use a custom tick source that tells the elapsed time in milliseconds.</span></span><br><span class="line"><span class="comment"> *It removes the need to manually update the tick with `lv_tick_inc()`)*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LV_TICK_CUSTOM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM_INCLUDE <span class="string">&quot;FreeRTOS.h&quot;</span>         <span class="comment">/*Header for the system time function*/</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LV_TICK_CUSTOM_SYS_TIME_EXPR (xTaskGetTickCount())    <span class="comment">/*Expression evaluating to current system time in ms*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   <span class="comment">/*LV_TICK_CUSTOM*/</span></span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  btim_timx_int_init(10-1, 7200-1);</span></span><br><span class="line"><span class="comment">//       lv_tick_inc(1);</span></span><br></pre></td></tr></table></figure></p><p>8.新建lvgl_demo.c/.h文件，创建OS任务，调用/编写demo   </p><p><img src="/img/freertos/lvgl_yizhi/15.png" alt="1"> </p><p>9.在main.c中包含头文件#include “lvgl_demo.h”，调用lvgl_demo();函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./SYSTEM/sys/sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./SYSTEM/usart/usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./SYSTEM/delay/delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./USMART/usmart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/LED/led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/LCD/lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/KEY/key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       清空屏幕并在右上角显示&quot;RST&quot;</span></span><br><span class="line"><span class="comment"> * @param       无</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Init();                         <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">    sys_stm32_clock_init(RCC_PLL_MUL9); <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                     <span class="comment">/* 延时初始化 */</span></span><br><span class="line">    usart_init(<span class="number">115200</span>);                 <span class="comment">/* 串口初始化为115200 */</span></span><br><span class="line">    led_init();                         <span class="comment">/* 初始化LED */</span></span><br><span class="line">    key_init();                         <span class="comment">/* 初始化按键 */</span></span><br><span class="line">    lvgl_demo();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>移植完成</strong></p><h3 id="移植遇到的坑"><a href="#移植遇到的坑" class="headerlink" title="移植遇到的坑"></a>移植遇到的坑</h3><h4 id="编译的时候报内存不够"><a href="#编译的时候报内存不够" class="headerlink" title="编译的时候报内存不够"></a>编译的时候报内存不够</h4><p>修改lv_conf.h，适当减小分配给LVGL管理的内存</p><p><img src="/img/freertos/lvgl_yizhi/16.png" alt="1"><br>将这个值适当改小</p><h4 id="运行的时候卡死在某界面不动"><a href="#运行的时候卡死在某界面不动" class="headerlink" title="运行的时候卡死在某界面不动"></a>运行的时候卡死在某界面不动</h4><p>增加栈空间</p><p><img src="/img/freertos/lvgl_yizhi/17.png" alt="1">   </p><p>可将这两个值改大</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习日记】FreeRTOS注意点(不定时更新)</title>
      <link href="/2023/12/30/FreeRTOS/zhuyi/"/>
      <url>/2023/12/30/FreeRTOS/zhuyi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文在于记录FreeRTOS的一些注意点。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>FreeRTOS的任务有四种状态，分别是<code>运行态、就绪态、阻塞态和挂起态</code>。<br>运行态：若一个任务正在运行，就说这个任务处于运行态。处于运行态的任务就是当前正在使用处理器的任务。如果使用的是单核处理器，那么无论在什么时候都只有一个任务处于运行态。<br>就绪态：处于就绪态的任务是指那些己经准备就绪，可以运行的任务，但当前未被调度度器选中从而未运行，因为有其他优先级更高的任务正在运行。<br>阻塞态：若一个任务当前正在等待某个外部事件发生，就说这个任务处于阻塞态。任务进入阻塞态会有一个超时时间，如果超过这个超时时间，任务就会退出阻塞态，即使所等待的事件还没有发生。<br>挂起态：挂起态类似于阻塞态，但任务进入挂起态后不能被调度器选中从而进入运行态，而且进入挂起态的任务没有超时时间。<br><code>运行态只能由就绪态转换而来。</code><br>个人理解：理论上还存在<code>第五种状态</code>，在任务被删除后，其TCB控制块仍保留一段时间，等待内核检查和回收资源，在内核没有处理之前，任务其实并没有被完全删除，但是再也不能被调度器调度，在这种状态下，需要通过空闲任务释放被删除任务的内存。<br><img src="/img/freertos/zhuyi/1.png" alt="1"><br>图片来源：<a href="https://blog.csdn.net/qq_42553054/article/details/129990967">CSDN不成大佬我是猪</a></p><h3 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h3><p>FreeRTOS的任务优先级本身是没有限制的。但是优先级数量越多，消耗的资源也越多。当配置configUSE_PORT_OPTIMISED_TASK_SELECTION为1时，即采用硬件方法查找下一个要运行的任务，由于硬件的限制，任务的优先级数量也会受到限制。对于STM32而言，使用硬件方法查找下一个要运行的任务时，任务优先级的数量最多为32个，即0-31。<code>优先级数值越大，代表优先级越高，这点和中断优先级正好相反。</code>对于同一优先级的多个任务，FreeRTOS将采用时间片调度运行这些任务，每个任务只运行一个时间片，如此反复。FreeRTOS的任务优先级通过链表实现，实际上任务调度管理的核心是<code>链表管理</code>。<br><img src="/img/freertos/zhuyi/2.png" alt="1">而其中<code>configMAX_PRIORITIES是在FreeRTOSConfig.h里设置的最大优先级</code>，pxReadyTasksLists[ N ]表示优先级为N的处于Ready/Running的任务</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习日记】FreeRTOS的移植(基于STM32F103ZET6)</title>
      <link href="/2023/12/28/FreeRTOS/yizhi/"/>
      <url>/2023/12/28/FreeRTOS/yizhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文在于总结正点原子的FreeRTOS教程，基于<code>HAL库</code>的<code>STM32F103ZET6</code>的代码移植。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先需要准备好HAL库的基础工程，在这里采用的是正点原子标准例程-HAL 库版本的内存管理的实验,然后还要准备 FreeRTOS 内核源码这里使用的是版本 V10.4.6，两个文件获取方式如下<br>·<a href="http://47.111.11.73/docs/boards/stm32/zdyz_stm32f103_jingyingV2.html">HAL库例程下载地址</a><br>·<a href="http://www.openedv.com/docs/book-videos/zdyzshipin/4free/newfreertos.html">FreeRTOS内核源码</a></p><h2 id="FreeRTOS源码文件内容介绍"><a href="#FreeRTOS源码文件内容介绍" class="headerlink" title="FreeRTOS源码文件内容介绍"></a>FreeRTOS源码文件内容介绍</h2><p>解压好压缩包后能看到以下文件<br><img src="/img/freertos/yizhi/1.png" alt="1">里面的Source文件为内核源码，也是我们需要的，打开Source文件后，大致内容如下<br><img src="/img/freertos/yizhi/2.png" alt="1"></p><div class="table-container"><table><thead><tr><th style="text-align:center">文件名</th><th style="text-align:center">大致内容</th></tr></thead><tbody><tr><td style="text-align:center">include</td><td style="text-align:center">FreeRTOS的头文件</td></tr><tr><td style="text-align:center">portable</td><td style="text-align:center">不同编译器与不同板子使用的接口文件</td></tr><tr><td style="text-align:center">croutine.c</td><td style="text-align:center">协程相关文件</td></tr><tr><td style="text-align:center">event_groups.c</td><td style="text-align:center">事件相关文件</td></tr><tr><td style="text-align:center">list.c</td><td style="text-align:center">列表相关文件</td></tr><tr><td style="text-align:center">queue.c</td><td style="text-align:center">队列相关文件</td></tr><tr><td style="text-align:center">stream_buffer.c</td><td style="text-align:center">流式缓冲区相关文件</td></tr><tr><td style="text-align:center">tasks.c</td><td style="text-align:center">任务相关文件</td></tr><tr><td style="text-align:center">timers.c</td><td style="text-align:center">软件定时器相关文件</td></tr></tbody></table></div><h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><p>这里简略说一下，具体请看FreeRTOS的开发指南<br>在<code>HAL库内存管理基础工程</code>的 <code>Middlewares</code> 文件夹中新建一个 <code>FreeRTOS</code> 子文件夹，将Source文件夹内的所有内容复制到刚创建的<code>FreeRTOS</code>文件夹中，其中<code>portable</code>文件夹只需保存以下三个文件<br><img src="/img/freertos/yizhi/3.png" alt="1"><br>在KEIL中添加两个分组，如图<br><img src="/img/freertos/yizhi/4.png" alt="1"><br>添加.c文件，<code>注意这里的heap_x.c用的是4,(heap.c对应5种内存管理算法)</code><br>添加头文件<br><img src="/img/freertos/yizhi/5.png" alt="1"><br>添加<code>FreeRTOSConfig.h</code>头文件</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>具体修改内容请参考正点原子FreeRTOS开发指南</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识FreeRTOS</title>
      <link href="/2023/12/27/FreeRTOS/one/"/>
      <url>/2023/12/27/FreeRTOS/one/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这一系列的文章目的主要是记录学习笔记，仅供参考。</p><h2 id="一、为什么要学习FreeRTOS"><a href="#一、为什么要学习FreeRTOS" class="headerlink" title="一、为什么要学习FreeRTOS"></a>一、为什么要学习FreeRTOS</h2><p>以往我们对单片机的开发通常是采用裸机开发。在裸机里，所有的操作都在一个While循环中进行；对于较为简单的系统，裸机通常是能够满足要求的。但是随着开发项目功能的增加，单纯的裸机需要考虑各个功能的逻辑，会使得编程难度加大。这时，采用<code>RTOS(Real Time Operating System)实时操作系统</code>是非常有必要的。采用<code>RTOS</code>可以实现多任务管理、调度。<code>RTOS</code>并不是值某一特定的操作系统，而是指一类操作系统，例如FreeRTOS，RTX，RT-Thread 等这些都是<code>RTOS</code>类的操作系统。而<code>FreeRTOS</code>是一款开源而且免费的实时操作系统。</p><h2 id="二、FreeRTOS的特点"><a href="#二、FreeRTOS的特点" class="headerlink" title="二、FreeRTOS的特点"></a>二、FreeRTOS的特点</h2><p>一、多任务系统。操作系统是允许多个任务<code>“同时运行”</code>的，操作系统的这个特性被称为多任务。实际上，一般使用的单片机只有一个核心，(一些高性能的芯片可能拥有多个核心，如英飞凌的TC364有两个核心，TC377有三个核心等等)。一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理任务，由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行的错觉。操作系统的分类方式可以由任务调度器的工作方式决定，比如有的操作系统给每个任务分配同样的运行时间，时间到了就切换到下一个任务，Unix 操作系统就是这样的。RTOS 的任务调度器被设计为可预测的，而这正是嵌入式实时操作系统所需要的。在实时环境中，要求操作系统必须实时地对某一个事件做出响应，因此任务调度器的行为必须是可预测的。像 FreeRTOS这种传统的 RTOS 类操作系统是由用户给每个任务分配一个任务优先级，任务调度器就可以根据此优先级来决定下一刻应该运行哪个任务。<br>二、免费。这是很重要的一点，因为在做项目时是要考虑产品的成本的，免费的FreeRTOS 操作系统就是一个很好的选择，当然了，也可以选择其他免费的 RTOS 操作系统。<br>三、使用广泛。许多半导体厂商和软件厂商都在其产品中使用了 FreeRTOS 操作系统。比如，许多的半导体厂商都会在其产品的 SDK 包中使用 FreeRTOS 操作系统，尤其是涉及 Wi-Fi、蓝牙等这些带协议栈的芯片或模块；著名的 GUI 设计软件库 TouchGFX 在其软件的应用例程中使用了 FreeRTOS 操作系统；ST 公司也在其 STM32Cube 生态系统中加入了对 FreeRTOS 操作系统的支持。<br>四、资料齐全。在 FreeRTOS 操作系统的官网上 <a href="https://www.freertos.org/">链接</a>，提供了大量的FreeRTOS 操作系统的相关文档及例程源码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布blog</title>
      <link href="/2023/12/27/fangdai/publish/"/>
      <url>/2023/12/27/fangdai/publish/</url>
      
        <content type="html"><![CDATA[<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文章名字&quot;</span><br></pre></td></tr></table></figure><h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h2 id="重新生成blog"><a href="#重新生成blog" class="headerlink" title="重新生成blog"></a>重新生成blog</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="本地预览blog"><a href="#本地预览blog" class="headerlink" title="本地预览blog"></a>本地预览blog</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s //注意地址只能右键复制，这个时候Ctrl+C是退出本地预览</span><br></pre></td></tr></table></figure><h2 id="上传到GIThub仓库"><a href="#上传到GIThub仓库" class="headerlink" title="上传到GIThub仓库"></a>上传到GIThub仓库</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网实践</title>
      <link href="/2023/05/10/mqtt/"/>
      <url>/2023/05/10/mqtt/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做了一个物联网的项目，基本内容是GPS+MQTT+微信小程序，GPS获取经纬度通过ESP8266上传到云服务器，然后微信小程序获取经纬度信息，在小程序里显示出当前位置的地图。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>说到物联网，首先必须得提到两个东西。第一个是<code>无线通信模块</code>这里我用的是国产的ESP8266-01S，01好像是得加一个上拉电阻才能用，这里无线通信还有比如<code>NB-IoT</code>等，无线通信模块的作用是接入互联网。第二个就是<code>通信协议</code>，最熟知的网络协议应该是<code>TCP/IP协议</code>。而在我们物联网中，最常用的是<code>MQTT协议</code>，<code>MQTT协议</code>是一个基于应用层的<code>TCP/IP协议</code>具体什么意思可以去了解一下网络协议，而<code>MQTT协议</code>就是我们物联网通信的规范。我们只需要知道这两个东西就行。想具体了解<code>MQTT协议</code>可以去看这篇博客 <a href="http://t.csdn.cn/d55sH">博客地址</a></p><h1 id="基础工作"><a href="#基础工作" class="headerlink" title="基础工作"></a>基础工作</h1><p>这里的准备工作是指完成STM32基础的开发，比如OLED屏幕外设驱动的移植，DHT11温湿度传感器等等，由于需求不同，我就不再赘述。</p><h1 id="MQTT相关内容的移植"><a href="#MQTT相关内容的移植" class="headerlink" title="MQTT相关内容的移植"></a>MQTT相关内容的移植</h1><p>MQTT的代码我们不可能自己去写，咱也没那个能力。其实这些东西早就有大佬给我们写好了，我们找到这些东西就行。<br>首先我们搜索<a href="https://open.iot.10086.cn/">OneNET</a>，进入网页的论坛，在搜索框找到OneNET开发板代码、资料，<a href="https://open.iot.10086.cn/bbs/thread-863-1-1.html">点这里</a>，然后打开百度网盘，下载OneNET标准版3.2的裸机-基础教程的代码，如下图<br><img src="/img/45.png" alt="1"></p><p>解压后我们打开MQTT-例程，里面的<code>esp8266.c文件</code>、<code>esp8266.h文件</code>、<code>MQTTKit.c文件</code>、<code>MQTTKit.h文件</code>、<code>onenet.c文件</code>、<code>onenet.h文件</code>就是我们所需要的文件，移植到我们自己的工程里，怎么移植我也不赘述了，移植好后工程文件如下<br><img src="/img/46.png" alt="1"><br>在这里我们也感谢一下这些白嫖代码的作者：张继瑞同志</p><h1 id="配置程序实现数据上传至MQTT服务器"><a href="#配置程序实现数据上传至MQTT服务器" class="headerlink" title="配置程序实现数据上传至MQTT服务器"></a>配置程序实现数据上传至MQTT服务器</h1><h2 id="Topic配置及订阅"><a href="#Topic配置及订阅" class="headerlink" title="Topic配置及订阅"></a>Topic配置及订阅</h2><p>我们首先需要加两个东西，订阅命令的Topic以及上行数据的Topic<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *devSubTopic[] = &#123;&quot;/mysmarthome1/sub&quot;&#125;;  #设备上行数据Topic</span><br><span class="line">const char devPubTopic[] = &quot;/mysmarthome1/pub&quot;;     #设备订阅的Topic</span><br></pre></td></tr></table></figure></p><p>在初始化结束加上这个函数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneNet_Subscribe(devSubTopic, 1);</span><br></pre></td></tr></table></figure></p><p>我们打开这个函数，可以看到这个函数的作用就是订阅我们在前面配置的Topic<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void OneNet_Subscribe(const char *topics[], unsigned char topic_cnt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned char i = 0;</span><br><span class="line"></span><br><span class="line">MQTT_PACKET_STRUCTURE mqttPacket = &#123;NULL, 0, 0, 0&#125;;//协议包</span><br><span class="line"></span><br><span class="line">for(; i &lt; topic_cnt; i++)</span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;Subscribe Topic: %s\r\n&quot;, topics[i]);</span><br><span class="line"></span><br><span class="line">if(MQTT_PacketSubscribe(MQTT_SUBSCRIBE_ID, MQTT_QOS_LEVEL0, topics, topic_cnt, &amp;mqttPacket) == 0)</span><br><span class="line">&#123;</span><br><span class="line">ESP8266_SendData(mqttPacket._data, mqttPacket._len);//向平台发送订阅请求</span><br><span class="line"></span><br><span class="line">MQTT_DeleteBuffer(&amp;mqttPacket);//删包</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="esp8266接入互联网"><a href="#esp8266接入互联网" class="headerlink" title="esp8266接入互联网"></a>esp8266接入互联网</h2><p>在这一步，我们需要配置两个东西，第一个是我们<code>WIFI的名称以及密码</code>，注意WIFI必须为<code>2.4GHZ</code>，并且连接过程中不需要登录操作，校园网就不行。<br>在<code>esp8266.c</code>中修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ESP8266_WIFI_INFO&quot;AT+CWJAP=\&quot; 这里填你的WIFI名称 \&quot;,\&quot; 你的WIFI密码 \&quot;\r\n&quot;</span><br></pre></td></tr></table></figure><br>第二个是配置我们订阅的<code>MQTT服务器的IP地址</code>以及<code>端口号</code>，这里如果想用自己的服务器，得买一个域名，配置ssl证书，最重要的是得进行<code>ICP备案</code>，整个过程有点复杂，后续可能会专门写一篇教程。这里我们其实用免费的就好，不过你后续微信小程序要发布的话，必须得用自己的服务器并且备案。<br>这里我们大陆MQTT的<a href="https://www.emqx.io/zh">官网</a>，找到MQTT下面的<code>公共MQTT服务器</code>，如图<br><img src="/img/47.png" alt="1"><br>这个Broker就是域名，我们在<code>esp8266.c</code>中修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ESP8266_ONENET_INFO&quot;AT+CIPSTART=\&quot;TCP\&quot;,\&quot;域名\&quot;,端口号\r\n&quot;</span><br></pre></td></tr></table></figure><br>这里端口号填1883</p><p>单片机控制esp8266是通过串口发送AT指令，这里我们看一下ESP8266的初始化代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void ESP8266_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);   //ESP8266复位引脚配置</span><br><span class="line">GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Initure.GPIO_Pin = GPIO_Pin_14;//GPIOC14-复位</span><br><span class="line">GPIO_Initure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOC, GPIO_Pin_14, Bit_RESET);</span><br><span class="line">delay_ms(250);</span><br><span class="line">GPIO_WriteBit(GPIOC, GPIO_Pin_14, Bit_SET);</span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">ESP8266_Clear();</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;0. AT\r\n&quot;);        //测试AT指令</span><br><span class="line">while(ESP8266_SendCmd(&quot;AT\r\n&quot;, &quot;OK&quot;))</span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;1. RST\r\n&quot;);       //ESP8266模块进行重启</span><br><span class="line">ESP8266_SendCmd(&quot;AT+RST\r\n&quot;, &quot;&quot;);</span><br><span class="line">delay_ms(500);</span><br><span class="line">ESP8266_SendCmd(&quot;AT+CIPCLOSE\r\n&quot;, &quot;&quot;);       //关闭单连接模式下的 TCP/UDP/SSL 连接</span><br><span class="line">delay_ms(500);</span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;2. CWMODE\r\n&quot;);    //进入station模式</span><br><span class="line">while(ESP8266_SendCmd(&quot;AT+CWMODE=1\r\n&quot;, &quot;OK&quot;))  </span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;3. AT+CWDHCP\r\n&quot;);  //启用DHCP（动态主机配置协议）</span><br><span class="line">while(ESP8266_SendCmd(&quot;AT+CWDHCP=1,1\r\n&quot;, &quot;OK&quot;))</span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;4. CWJAP\r\n&quot;);      //连接设定的WIFI</span><br><span class="line">while(ESP8266_SendCmd(ESP8266_WIFI_INFO, &quot;GOT IP&quot;))</span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;5. CIPSTART\r\n&quot;);   //连接服务器</span><br><span class="line">while(ESP8266_SendCmd(ESP8266_ONENET_INFO, &quot;CONNECT&quot;))</span><br><span class="line">delay_ms(500);</span><br><span class="line"></span><br><span class="line">UsartPrintf(USART_DEBUG, &quot;6. ESP8266 Init OK\r\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所有配置完成后，我们打开串口助手查看ESP8266的连接<br><img src="/img/48.png" alt="1"><br>这样则连接成功，失败的话可以重新上电或者长按复位按键</p><p>我们在main函数的循环里加入<code>OneNet_Publish(devPubTopic, PUB_BUF);</code>函数，PUB_BUF为上传的内容数组</p><h2 id="使用MQTT-fx软件查看发布内容"><a href="#使用MQTT-fx软件查看发布内容" class="headerlink" title="使用MQTT.fx软件查看发布内容"></a>使用MQTT.fx软件查看发布内容</h2><p>我们下载一个MQTT.fx软件，进行调试<br>新建一个项目<br><img src="/img/49.png" alt="1"><br>在Broker.address中填入公共服务器的地址，进行连接<br>在Subscribe中填入之前配置的订阅topic进行订阅<br><img src="/img/50.png" alt="1"><br>能看到我们单片机上采集的数据，这部分配置程序实现数据上传至MQTT服务器就到这</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 物联网 </tag>
            
            <tag> MQTT协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复刻Super Dial电机旋钮屏</title>
      <link href="/2023/03/19/super/"/>
      <url>/2023/03/19/super/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几天前在bilibili刷到了电机旋钮屏的项目，觉得可玩性高，便打算复刻一个</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>灵感来源与国外的<code>smart konb</code>，制作初衷为制作一个桌面力反馈旋钮，可实现与<code>surface dial</code>一样的功能。<br>开源协议: Public Domain</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>灵感来源与国外的smart konb，制作初衷为制作一个桌面力反馈旋钮，可以与电脑进行交互。项目从最重要的电机入手，选择了量大便宜的3205电机（小米云台电机的库存货），在结构上实现上下等大，增加实用功能蓝牙hid（轮盘功能），可实现与<code>surface dial</code>一样的功能。</p><h1 id="制作说明"><a href="#制作说明" class="headerlink" title="制作说明"></a>制作说明</h1><p>附件在gitee <a href="https://gitee.com/coll45/super-dial-motor-knob-screen">下载地址</a></p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>硬件部分为三块pcb,一块主控板，一块驱动板，一块屏幕固定驱动板</p><p><img src="/img/41.png" alt="1"></p><center>主控板</center><p><img src="/img/42.png" alt="1"></p><center>电机驱动板</center><p><img src="/img/43.png" alt="1"></p><center>屏幕驱动板</center><p>PCB工程 <a href="https://oshwhub.com/45coll/a2fff3c71f5d4de2b899c64b152d3da5">下载地址</a></p><h2 id="3D打印"><a href="#3D打印" class="headerlink" title="3D打印"></a>3D打印</h2><p>打印件可以通过三维猴打印，直接上传<code>3D打印和CNC模型-by虫二</code>文件夹内的stl即可，一共四个打印件（选择外壳cnc就用cnc的step）<br><img src="/img/44.png" alt="1"></p><h2 id="代码烧录"><a href="#代码烧录" class="headerlink" title="代码烧录"></a>代码烧录</h2><p>打开附件文件夹内的<code>bin/flash_download_tool_3.9.2.exe</code> 选择esp32s3，其他什么都不改（super_dial_v2.bin烧录到0x0位置）。然后通过usb-ttl连接到主控板，tx-rx rx-tx gnd -gnd，连接完成之后，按住boot按钮（sw1）然后接入typec亮起3.3v指示灯，然后松开boot按钮，点start开始烧录。烧录完成后拔掉typec 再次插入就可以看见效果</p><p>USB烧录方法：打开附件文件夹内的<code>bin/flash_download_tool_3.9.2.exe</code> 选择esp32s3，loadmod改成USB其他什么都不改（super_dial_v2.bin烧录到0x0位置），先按住boot键，然后USB数据线连接。点start开始烧录。烧录完成后拔掉typec 再次插入就可以看见效果</p><p>OTA烧录方法（只限于烧录过程序，但是想更新最新固件）：旋钮进入设置界面（wifi界面，有圆圈在转动的）然后连接esp32的wifi热点。连接成功后打开浏览器输入192.168.4.1进入界面选择文件夹/bin/OTA/ota_v2.bin。点击上传即可，上传过程中会出现转圈卡顿的情况表示正常上传，上传完成后会自动重启。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>在Gitee附件中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> ESP32 </tag>
            
            <tag> Super Dial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netlify自定义域名</title>
      <link href="/2023/03/01/yuming/"/>
      <url>/2023/03/01/yuming/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Netlify托管个人博客后，Netlify会默认给我们生成一个域名，但是这个域名没有任何意义且复杂。我们可以自定义这个域名。</p><h1 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h1><p>首先需要购买一个自己的域名，可以在阿里云，腾讯云等购买，博主的域名在阿里云购买，价格为8元/年<br><img src="/img/28.png" alt="1"><br>等待域名实名认证<br><img src="/img/29.png" alt="1"></p><h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><p>在Netlify上添加自定义域名<br><img src="/img/30.png" alt="1"></p><p>去域名控制台解析一条CNAME记录，记录值为你的Netlify生成的域名，生成二级域名<br><img src="/img/31.png" alt="1"></p><h1 id="添加SSL"><a href="#添加SSL" class="headerlink" title="添加SSL"></a>添加SSL</h1><p>此时的博客在访问时会有网站不安全的标志，我们需要添加<code>SSL证书</code><br>Netlify也提供免费证书发放服务，点击<code>Let&#39;s Encrypt</code>申请证书<br><img src="/img/32.png" alt="1"></p><p>等待证书发放，这样就可以通过购买的域名访问博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Netlify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建个人博客</title>
      <link href="/2023/02/25/blog/"/>
      <url>/2023/02/25/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>历时两天，终于将博客搭建成功，先写一下如何用Hexo+Github搭建自己的博客</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h3 id="安装Git-Bash"><a href="#安装Git-Bash" class="headerlink" title="安装Git Bash"></a>安装Git Bash</h3><p>Git Bash <a href="https://github.com/git-for-windows/git/releases/download/v2.11.0.windows.3/Git-2.11.0.3-64-bit.exe">下载地址</a></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Node.js <a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi">下载地址</a></p><h3 id="检查是否成功安装"><a href="#检查是否成功安装" class="headerlink" title="检查是否成功安装"></a>检查是否成功安装</h3><p>打开cmd(命令提示符)输入以下代码进行检查<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v </span><br><span class="line">npm -v</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><br>若成功安装，则会出现以下类似的版本号<br><img src="/img/3.png" alt="1"><br>打开cmd安装Hexo<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><h3 id="github仓库配置"><a href="#github仓库配置" class="headerlink" title="github仓库配置"></a>github仓库配置</h3><p>github注册就不在此赘述了，请自行百度</p><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>新建一个仓库,名称为<font style="background:lightgrey;color:tomato">你的用户名.github.io</font>,例如你的github用户名为<font style="background:lightgrey;color:tomato">byj</font>，则你需要建的名称为<font style="background:lightgrey;color:tomato">byj.github.io</font></p><h4 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h4><p>打开任意一个文件夹，右键运行Git Bash Here<br><img src="/img/5.png" alt="1"><br>进入Git页面<br><img src="/img/4.png" alt="1"><br>输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh     #检查是否安装了ssh   </span><br></pre></td></tr></table></figure><p>生成ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa -C &quot;你的邮件地址&quot;    </span><br></pre></td></tr></table></figure><p><font style="background:lightgrey;color:tomato">输入后需要敲4次回车</font><br>见到如下内容则代表成功<br><img src="/img/6.png" alt="1"><br>打开C盘下的Users文件夹，打开Administrator文件夹，找到<font style="background:lightgrey;color:tomato">.ssh</font>文件夹，打开id_rsa.pub文件，复制其中的秘钥<br>将秘钥复制进Git Hub中，如图<br><img src="/img/7.png" alt="1"><br><img src="/img/8.png" alt="1"><br><img src="/img/9.png" alt="1"></p><h1 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h1><p>在Git Bash中依次输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init     #初始化Hexo博客   </span><br><span class="line">hexo g        #生成博客</span><br><span class="line">hexo s        #生成静态本地博客页面</span><br></pre></td></tr></table></figure><br>此时会看到Git Bash给了你一个网址<br><img src="/img/11.png" alt="1"><br>通过该网址即可进入你的本地博客<br><img src="/img/12.png" alt="1"><br>接下来，就需要将我们的博客文件上传至GitHub仓库了</p><h1 id="上传至GitHub"><a href="#上传至GitHub" class="headerlink" title="上传至GitHub"></a>上传至GitHub</h1><p>打开Blog根目录下的<font style="background:lightgrey;color:tomato">_config.yml</font>文件，翻至最后，修改deploy配置如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:你的github名字/你的github名字.github.io.git   #不会可直接复制下图红圈填在这</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><br><img src="/img/13.png" alt="1"><br>安装hexo-deployer-git自动部署发布工具<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>依次执行以下三条指令</p><p><font style="background:lightgrey;color:tomato">hexo clean</font></p><p><font style="background:lightgrey;color:tomato">hexo g</font></p><p><font style="background:lightgrey;color:tomato">hexo d</font><br>在弹出的Git Hub登陆界面输入账号和密码<br>随后会提示让你输入令牌</p><h1 id="获取GitHub令牌"><a href="#获取GitHub令牌" class="headerlink" title="获取GitHub令牌"></a>获取GitHub令牌</h1><p>在github中找到settings<br>进入Developer settings<br><img src="/img/14.png" alt="1"><br>新建一个令牌<br><img src="/img/15.png" alt="1"><br>在之前弹出的登陆界面粘贴刚才生成的令牌<br>等待上传成功</p><h1 id="进入博客"><a href="#进入博客" class="headerlink" title="进入博客"></a>进入博客</h1><p>进入你的github博客仓库，进入settings<br><img src="/img/16.png" alt="1"><br>进入Pages获得你的博客网址<br><img src="/img/17.png" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netlify部署博客</title>
      <link href="/2023/02/25/%E5%8A%A0%E9%80%9F/"/>
      <url>/2023/02/25/%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Github Pages部署的博客具有一个很大的问题就是GitHub服务器在国外，所以国内访问速度很慢。如何简单快速又低成本的解决这个问题呢？我采用的是<font style="background:lightgrey;color:tomato">Netlify</font></p><p><font style="background:lightgrey;color:tomato">Netlify</font>是一家提供静态网站托管的综合平台，支持自动从Github等仓库拉取代码并构建成静态网站进行发布，同时也支持自定义域名，自动申请SSL证书等功能，更为重要的是自动启用CDN加速，访问速度会快很多</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>这里只需要一个Git Hub账号<br>进入Netlify官网，使用Git Hub账号注册<br><img src="/img/19.png" alt="1"><br><img src="/img/20.png" alt="1"></p><h1 id="创建站点"><a href="#创建站点" class="headerlink" title="创建站点"></a>创建站点</h1><p><img src="/img/21.png" alt="1"><br>选择GitHub代码托管<br><img src="/img/22.png" alt="1"><br>选择你的博客仓库，完善信息，点击Deploy site，系统就会自动编译你的静态页面<br><img src="/img/23.png" alt="1"></p><h1 id="获取站点地址"><a href="#获取站点地址" class="headerlink" title="获取站点地址"></a>获取站点地址</h1><p><img src="/img/24.png" alt="1"><br>通过这个地址你就能访问你的博客，速度会有很大提升</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Netlify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile详解</title>
      <link href="/2023/02/24/%E4%BB%A3%E7%A0%81%E5%9D%97/volatile/"/>
      <url>/2023/02/24/%E4%BB%A3%E7%A0%81%E5%9D%97/volatile/</url>
      
        <content type="html"><![CDATA[<p>volatile——易变的，大部分人都知道它的作用是确保本条指令不会被编译器的优化而忽略。在这里举几个例子进行解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如在这种情况时，多次使用了i变量，编译器可能会对其进行优化，第一次在使用这个变量时，它会去读内存，把这个变量的值读进CPU的某个寄存器，在后面的使用中，它一直去通过读这个寄存器获取变量的值，但是这个值是这个变量最原始的值，它并没有每次去内存中读这个变量，去更新这个值，这样就会出现一些问题，尤其是对于嵌入式而言。</p><h3 id="场景一：中断服务程序中修改的供其它程序检测的变量"><a href="#场景一：中断服务程序中修改的供其它程序检测的变量" class="headerlink" title="场景一：中断服务程序中修改的供其它程序检测的变量"></a>场景一：中断服务程序中修改的供其它程序检测的变量</h3><p>当变量在触发某中断程序中修改，而编译器判断主函数里面没有修改该变量，因此可能只执行一次从内存到某寄存器的读操作，而后每次只会从该寄存器中读取变量副本，使得中断程序的操作被短路。</p><h3 id="场景二：多任务环境下各任务间共享的标志"><a href="#场景二：多任务环境下各任务间共享的标志" class="headerlink" title="场景二：多任务环境下各任务间共享的标志"></a>场景二：多任务环境下各任务间共享的标志</h3><p>在某个任务中，编译器对变量进行优化，把这个变量的值读进CPU的某个寄存器，在后面的使用中，它通过读这个寄存器获取变量的值，但是在另一个任务中，改变了这个变量的值，但是这个寄存器的值并不会进行改变，从而造成应用程序读取的值和实际的变量值不一致。</p><h3 id="场景三：存储器映射的硬件寄存器"><a href="#场景三：存储器映射的硬件寄存器" class="headerlink" title="场景三：存储器映射的硬件寄存器"></a>场景三：存储器映射的硬件寄存器</h3><p>假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。for(i=0;i&lt; 10;i++) *output = i;前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，省略了对该硬件IO端口反复读的操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>volatile应该解释为“直接存取原始内存地址”相对于“易变的”更合适，volatile对应的变量可能在你的程序本身不知道的情况下发生改变。<br><strong>什么时候一定要将变量定义为volatile？</strong></p><ul><li>寄存器变量</li><li>被中断历程使用的全局变量</li><li>被多个线程使用的全局变量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2023/02/24/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/"/>
      <url>/2023/02/24/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2023/02/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2023/02/24/hello-world/"/>
      <url>/2023/02/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
